[%
USE Dumper;
USE Math;
USE date;
USE format;

datenow.value = date.now();
datenow.month_end   = date_format(month_end  (datenow.value), noyear = 1 );
datenow.month_start = date_format(month_start(datenow.value), noyear = 1 );
datenow.year=date.format(datenow.value,'%Y');
IF invoice.serial;
    invoice.serial=Math.int(ifz(invoice.serial))|format('%06d');
    #invoice.date_start = '00:00:00 01-' _ invoice.month _ invoice.year;
    invoice.date_start = '00:00:00 01-05-2014';
    invoice.date_end   = month_end(invoice.date_start);
END;


MACRO date_format(dateval,noyear) BLOCK;
date.format(dateval,'%B'); ordinate(date.format(dateval,'%e')); IF !noyear; date.format(dateval,'%Y'); END;
END;
MACRO month_start(dateval) BLOCK;
'00:00:00 01-' _ date.format(dateval,'%m-%Y');
END;
MACRO month_end(dateval) BLOCK;
'00:00:00 00-' _ (Math.int(ifz(date.format(dateval,'%m'))) + 1) _ date.format(dateval,'-%Y');
END;
MACRO money_format_comma(value) BLOCK;
value = ifz(value); value = money_format(value);value= value.replace('\.',',');value;
END;

MACRO ordinate(num) BLOCK;
      IF num.search('(?<!1)1$');
          sfx = 'st';
      ELSIF num.search('(?<!1)2$');
          sfx = 'nd';
      ELSIF num.search('(?<!1)3$');
          sfx = 'rd';
      ELSE;
          sfx = 'th';
     END;
      num _ sfx;
END;

MACRO if(prefix, value) BLOCK;
    value_clear = value.replace('[ ,]','');
     IF value_clear ;
         prefix _ value ;
    END;
END;
MACRO ife(value,suffix) BLOCK ;
    value_clear = value.replace('[ ,]','');
     IF value_clear ;
         value _ suffix ;
    END;
END;

MACRO ifz(value, default) BLOCK;
    value_clear = value.replace(' *|\s*','');
    IF !default; default = 0; END;
    IF !value_clear ;
         value = default ;
    END;value;END;


MACRO getDy(rows_interval_in, rownumber) BLOCK ;
    rows_interval = ( ifz(rows_interval_in) > 0 ) ? rows_interval_in : row_vertical_interval;
    dy = ( ifz(rows_interval) * ( ifz(rownumber) - 1 ) );
    dy;
END;

MACRO adjustrow(data, rowtype, dy, return_y, params) BLOCK ;
    IF rowtype == 'datarow' ;
        row = datarow(data);
    ELSIF rowtype == 'totalrow' ;
        row = totalrow( data );
    ELSE;
        row = rowtype;
    END;
    #to avoid errors if some node of the same type are on the root level
    row = '<svg>' _ row _ '</svg>';
    y_all = [];
    USE xpath = XML.XPath(row);
    FOREACH y_attr_el IN xpath.find('//@y');
        FOREACH y_attr_node IN y_attr_el.get_nodelist();
            y_old = Math.int(ifz(y_attr_node.getNodeValue('y'))) ;
            y = ifz(y_old) + dy ;
            y_all.push(y);
            t=y_attr_node.setNodeValue(y);
        END;
    END;
    res;
    IF !return_y;
        row = xpath.findnodes('/').toString();
        row = row.replace('^<svg>|<\/svg>$','');
        res = row;
    ELSE;
        y_all = y_all.nsort();
        IF return_y != 'min';
            y_all = y_all.reverse();
        END;
        res = y_all.0;
    END;
    res;
END ;

MACRO list_zones(params) BLOCK;
     FOREACH call IN params.data ;#invoice_details;
        IF call.1; calldata = call.1; ELSE; calldata = call; END;
        FOREACH colname IN ['number','duration','free_time','source_customer_cost'];
            calldata.${colname} = ifz(calldata.get_column(colname));
            params.total.zonepage.perpage.${pagelocal}.${colname} = ifz(params.total.zonepage.perpage.${pagelocal}.${colname}) + calldata.${colname};
        END;
        params.total.zonepage.perpage.${pagelocal}.cost = ifz(params.total.perpage.${pagelocal}.cost) + ( Math.int(calldata.source_customer_cost) / 100) ;
        dy = getDy(params.rowsinterval, loop.count);
        adjustrow(calldata, 'datarow',  dy, '', params => params) ;
    END ;
END ;

MACRO list_calls(params) BLOCK;
    FOREACH call IN params.data ;#invoice_details;
        IF call.1; calldata = call.1; ELSE; calldata = call; END;
        FOREACH colname IN ['source_customer_cost','duration'];
            calldata.${colname} = ifz(calldata.get_column(colname));
            params.total.callpage.perpage.${pagelocal}.${colname} = ifz(params.total.callpage.perpage.${pagelocal}.${colname}) + calldata.${colname};
        END;
        params.total.callpage.perpage.${pagelocal}.cost = ifz(params.total.callpage.perpage.${pagelocal}.cost) + ( Math.int(calldata.source_customer_cost) / 100 ) ;
        dy = getDy(params.rowsinterval, loop.count());
        adjustrow(calldata, 'datarow', dy, '', params => params) ;
    END ;
END ;

MACRO count_total(total, list, pagetype) BLOCK;
    FOR call IN list ;#invoice_details;
        IF call.1; calldata = call.1; ELSE; calldata = call; END;
        vars = ['source_customer_cost','duration'];
        IF pagetype == 'zonepage'; vars.push('number','free_time'); END;
        FOREACH colname IN vars;#
            calldata.${colname} = ifz(calldata.get_column(colname));
            total.${pagetype}.global.${colname} = ifz(total.${pagetype}.global.${colname}) + calldata.${colname};
        END;
        total.${pagetype}.global.cost = ifz(total.${pagetype}.global.cost) + ( Math.int(calldata.source_customer_cost) / 100 );
    END ;
    total.${pagetype}.global.source_customer_cost = total.${pagetype}.global.cost;
END;

MACRO get_page(pagetype) BLOCK ;
    #use this macro until no symbolic references in tt ;
    #data can be empty, if we just need y - it doesn't depend on data ;
    IF pagetype == 'titlepage' ;
        page = titlepage();
    ELSIF pagetype == 'zonepage' ;
        page = zonepage();
    ELSIF pagetype == 'callpage' ;
        page = callpage();
    ELSE;
        page = pagetype;
    END;
    page;
END;

MACRO get_page_rows_number(pagetype, rows_type, listsize) BLOCK;
    rows_type = rows_type ? rows_type _ '-' : '' ;
    page_rows_re = rows_type _ 'rows="([0-9]+)(?:,([0-9]+))?"' ;
    page = get_page(pagetype);
    matches = page.match( page_rows_re );
    IF matches.size > 0;
        rows = matches.0;
        #so if we can show only 2 records with all bottoms, and 13 with totalrow only, and list has 16 rows - then show 13 with totalrow only
        #IF matches.1 && matches.1 < ifz(listsize);
        IF matches.1 ;
            rows = matches.1;
        END;
    END;
    IF rows > ifz(listsize);
        rows = ifz(listsize);
    END;
    rows = Math.int(ifz(rows));
    rows;
END ;

MACRO get_page_interval(pagetype, interval_type) BLOCK;
    interval_type = interval_type ? interval_type _ '-' : '' ;
    page_interval_re = interval_type _ 'rows-interval="([0-9]+)"' ;
    page = get_page(pagetype) ;
    matches = page.match( page_interval_re ) ;
    interval = matches.0 || matches.1 ;
    interval = Math.int(ifz(interval));
    interval;
END ;

MACRO show_pages(invoice_details_zones, invoice_details_calls, pagetype, pagenum_in) BLOCK;
#todo: remove copypast with some macro, later;
    
    #pagewithblock();
    
    total = { callpage=> {perpage => [], global => {}}, zonepage => {perpage => [], global => {}} } ;
    count_total(total, invoice_details_zones,'zonepage');
    count_total(total, invoice_details_calls,'callpage');
    DEFAULT invoice.amount_netto = ifz(total.callpage.global.cost) + ifz(total.zonepage.global.cost) + ifz(bp.interval_charge);
    DEFAULT invoice.amount_vat = ifz(invoice.amount_netto) * ifz( bp.vat_rate) / 100 ;
    DEFAULT invoice.amount = ifz(invoice.amount_netto) + ifz(invoice.amount_vat) ;
    DEFAULT invoice.amount_payment = invoice.amount - ifz(invoice.debit) ;
    
    alltitlepages = ifz(alltitlepages) ? alltitlepages : 1;
    allzonerowsnumber = invoice_details_zones.size() ;
    titlezonerows =  get_page_rows_number('titlepage','zone', allzonerowsnumber) ;
    midzonerows = get_page_rows_number('zonepage') ;
    titlezoneinterval =  get_page_interval('titlepage','zone') ;
    midzoneinterval =  get_page_interval('zonepage') ;
    midzonerows = Math.int(get_page_rows_number('zonepage')) ;
    midzonerows = ( midzonerows < 1 ) ? 30 : midzonerows ;
    
    allmidzonepages = ( (allzonerowsnumber - titlezonerows) / midzonerows )|format('%d') ;
    allmidzonerows = allmidzonepages * midzonerows ;
    lastzonerows = allzonerowsnumber - allmidzonerows - titlezonerows ;
    allzonepages = allmidzonepages + ( lastzonerows > 0 ? 1 : 0 ) ;

    
    allcallrowsnumber = invoice_details_calls.size() ;
    titlecallrows =  get_page_rows_number('titlepage','call', allcallrowsnumber) ;
    midcallrows = Math.int(get_page_rows_number('callpage')) ;
    midcallrows = ( midcallrows < 1 ) ? 30 : midcallrows ;
    titlecallinterval =  get_page_interval('titlepage', 'call') ;
    midcallinterval =  get_page_interval('callpage') ;

    allmidcallpages = ( (allcallrowsnumber - titlecallrows) / midcallrows )|format('%d') ;
    allmidcallrows = allmidcallpages * midcallrows ;
    lastcallrows = allcallrowsnumber - allmidcallrows - titlecallrows ;
    allcallpages = allmidcallpages + ( lastcallrows > 0 ? 1 : 0 ) ;
    IF ( pagetype == 'title' || pagetype=='all') ;
        pagenum = 1;
        output_title = output_title _ document_header();
        params = { 
            'pagenum'   => pagenum, 
            'zonesdata' => ( ( titlezonerows > 0 ) && ( invoice_details_zones.size() > 0 ) ) ? invoice_details_zones.slice(0, titlezonerows - 1 ) : [],
            'pagelocal' => pagenum,
            'pageslocalnum' => 1 + allzonepages,
            'titlezoneinterval' => titlezoneinterval ,
            'total' => total,
            'titlezonerows' => titlezonerows,
        };
        output_title = output_title _ titlepage(params) ;
        output_title = output_title _ bgpage(params) ;
        output_title = output_title _ document_footer();
        alltitlepages = params.pagenum;
    END;    
    IF ( pagetype == 'zone' || pagetype=='all' ) && allzonerowsnumber ;
        pages = pagenum_in ? [ pagenum_in ] : [ 1 .. allmidzonepages ] ;
        FOREACH pagenum IN pages ;
            pagerowsstart = titlezonerows + midzonerows * ( pagenum - 1 );
            pagerowsend = titlezonerows + midzonerows * pagenum - 1 ;
            output = output _ document_header();
            params = { 
                'data' => invoice_details_zones.slice( pagerowsstart,  pagerowsend ),
                'pagenum'   => pagenum + alltitlepages, 
                'pagelocal'   => pagenum, 
                'pageslocalnum'  => allzonepages, 
                'rowsinterval' => midzoneinterval ,
                'total' => total,
            };
            output = output _ zonepage( params ) ;
            #+1 because of 1 for titlepage ;
            output = output _ bgpage(params) ;
            output = output _ document_footer();
            allzonepages = params.pagenum;
        END;
        IF lastzonerows > 0 ;
            #+1 is for last page number, so ( alltitlepages + allmidzonepages ) was previous page
            output = output _ document_header();
            params = { 
                'data' => invoice_details_zones.slice( allzonerowsnumber - lastzonerows ),
                'pagenum'   => 1 + alltitlepages + allmidzonepages, 
                'pagelocal'   => allzonepages, 
                'pageslocalnum'  => allzonepages, 
                'rowsinterval' => midzoneinterval ,
                'total' => total,
            };
            output = output _ zonepage( params ) ;
            #pagenum could change due to invoice footer
            output = output _ bgpage(params) ;
            output = output _ document_footer();
            allzonepages = params.pagenum;
        END;
    END;
    
    IF ( pagetype == 'call' || pagetype=='all' );
        pages = pagenum_in ? [ pagenum_in ] : [ 1 .. allmidcallpages ] ;
        FOREACH pagenum IN pages ;
            pagerowsstart = titlecallrows + midcallrows * ( pagenum - 1 );
            pagerowsend = titlecallrows + midcallrows * pagenum - 1 ;
            output = output _ document_header();
            params = { 
                'data' => invoice_details_calls.slice( pagerowsstart,  pagerowsend ),
                'pagenum'   => pagenum + alltitlepages + allzonepages, 
                'pagelocal'   => pagenum, 
                'pageslocalnum'  => allcallpages, 
                'rowsinterval' => midcallinterval ,
                'total' => total,
            };
            output = output _ callpage( params  ) ;
            output = output _ bgpage( params ) ;
            output = output _ document_footer();
        END;
        IF lastcallrows > 0 ;
            #2 because callpages started from 1, not from 0, and we need add 1 for titlepage ;
            output = output _ document_header();
            params = { 
                'data' => invoice_details_calls.slice( allcallrowsnumber - lastcallrows ),
                'pagenum'   => 1 + alltitlepages + allmidcallpages + allzonepages , 
                'pagelocal'   => allcallpages, 
                'pageslocalnum'  => allcallpages, 
                'rowsinterval' => midcallinterval,
                'total' => total,
            };
            output = output _ callpage( params ) ;
            output = output _ bgpage( params ) ;
            output = output _ document_footer();
        END;
    END;
        

    output_title _ output;
END;
%]